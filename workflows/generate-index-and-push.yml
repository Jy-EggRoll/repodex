name: Generate Repository File Index JSON and Push to KV

on:
  push:  # 任何推送操作都会触发，请注意不要在本工作流中执行向本仓库的推送操作，这可能造成工作流的循环触发
  workflow_dispatch:  # 允许手动触发工作流

jobs:
  generate-and-push:
    name: Generate Index and Push
    runs-on: ubuntu-latest

    steps:
      - name: Check required secrets  # 在用户未配置必要 Secrets 时提前失败，避免浪费资源
        shell: bash
        env:
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_NAMESPACE_ID: ${{ secrets.CF_NAMESPACE_ID }}
        run: |
          missing=0
          for name in CF_API_TOKEN CF_ACCOUNT_ID CF_NAMESPACE_ID; do
            if [ -z "${!name}" ]; then
              echo "Missing secret: $name" >&2
              missing=1
            fi
          done
          if [ "$missing" -eq 1 ]; then
            echo "Required secrets are missing. Aborting workflow." >&2
            exit 1
          fi

      - name: Checkout Source Code
        uses: actions/checkout@v4
        with:
          path: source-repo
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Generate JSON Index
        id: generate_step
        shell: python
        working-directory: source-repo
        run: |
          import json
          import subprocess
          import os
          import sys

          # 设置 core.quotepath 为 false，强制 Git 输出原始的中文字符，而不是八进制转义序列，这可以保证索引中的中文文件名字全是正确的
          subprocess.run(["git", "config", "--global", "core.quotepath", "false"])

          def run_command(command):
              try:
                  output = subprocess.check_output(command, shell=True, stderr=subprocess.PIPE)
                  return output.decode('utf-8').strip()
              except subprocess.CalledProcessError as e:
                  print(f"Error executing: {command}", file=sys.stderr)
                  return ""

          # 1. 获取仓库名并规范化文件名
          repo_full_name = os.environ.get('GITHUB_REPOSITORY', 'unknown/repo')
          repo_short_name = repo_full_name.split('/')[-1]
          
          # 构造目标文件名："仓库名-index.json"
          json_filename = f"{repo_short_name}-index.json"
          print(f"Target JSON Filename: {json_filename}")

          # 2. 获取分支列表
          raw_branches = run_command("git branch -r").split('\n')
          target_branches = []
          for b in raw_branches:
              b = b.strip()
              if not b or '->' in b: continue
              # 提取纯净分支名
              target_branches.append(b.replace('origin/', ''))

          # 3. 遍历分支收集数据
          branches_data_list = []
          for branch_name in target_branches:
              branch_data = {
                  "branch_name": branch_name,
                  "files": [],
                  "directories": []
              }

              # 获取文件（带大小）
              files_cmd = f"git ls-tree -r -l --full-tree origin/{branch_name}"
              files_output = run_command(files_cmd)
              if files_output:
                  for line in files_output.split('\n'):
                      # 分割模式、类型、Hash、大小、路径
                      # 使用 maxsplit=4 防止文件名中的空格被错误分割
                      parts = line.split(maxsplit=4)
                      if len(parts) < 5: continue
                      if parts[1] != 'blob': continue  # 只保留文件

                      size_str = parts[3].strip()
                      try:
                          size = int(size_str) if size_str.isdigit() else 0
                      except ValueError:
                          size = 0

                      original_path = parts[4]
                      branch_data["files"].append({
                          "name": os.path.basename(original_path),
                          "path": f"./{original_path}",
                          "size": size
                      })

              # 获取文件夹
              dirs_cmd = f"git ls-tree -r -d --full-tree origin/{branch_name}"
              dirs_output = run_command(dirs_cmd)
              if dirs_output:
                  for line in dirs_output.split('\n'):
                      parts = line.split(maxsplit=3)
                      if len(parts) < 4: continue
                      original_path = parts[3]
                      branch_data["directories"].append({
                          "name": os.path.basename(original_path),
                          "path": f"./{original_path}"
                      })

              branches_data_list.append(branch_data)

          # 4. 构建最终数据
          final_json = {
              "repository": repo_full_name,
              "repository_short_name": repo_short_name,
              "branches": branches_data_list
          }

          # 5. 为了方便后续步骤使用，将文件保存到上一级目录（runner workspace root）
          # 这样即使我们在 source-repo 目录下，文件也能在 checkout 目标仓库时被轻松找到
          output_path = os.path.abspath(f"../{json_filename}")

          with open(output_path, 'w', encoding='utf-8') as f:
              json.dump(final_json, f, ensure_ascii=False, indent=4)

          print(f"JSON generated: {output_path}")

          # 6. 将文件名导出到 GitHub Actions 环境变量，供后续步骤使用
          # 使用 GITHUB_ENV 文件写入环境变量
          with open(os.environ['GITHUB_ENV'], 'a', encoding='utf-8') as env_file:
              env_file.write(f"INDEX_FILENAME={json_filename}\n")
              env_file.write(f"INDEX_FILE_PATH={output_path}\n")

      - name: Upload index to Cloudflare KV
        env:
          CF_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
          CF_NAMESPACE_ID: ${{ secrets.CF_NAMESPACE_ID }}
          INDEX_FILE_PATH: ${{ env.INDEX_FILE_PATH }}
          INDEX_FILENAME: ${{ env.INDEX_FILENAME }}
        run: |
          echo "Upload ${INDEX_FILE_PATH} to Cloudflare KV namespace ${CF_NAMESPACE_ID}"
          KEY="${INDEX_FILENAME%.*}"
          resp=$(curl -sS -X PUT "https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/storage/kv/namespaces/${CF_NAMESPACE_ID}/values/${KEY}" -H "Authorization: Bearer ${CF_API_TOKEN}" -H "Content-Type: application/json; charset=utf-8" --data-binary @"${INDEX_FILE_PATH}")
          echo "$resp" | grep -q '"success":false' && { echo "Cloudflare API returned false" >&2; echo "$resp" >&2; exit 1; }
          echo "Uploaded ${KEY}"
